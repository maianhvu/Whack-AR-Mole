//
//  WMIdentifiedFiducial.m
//  Whack-AR-Mole
//
//  Created by Mai Anh Vu on 6/4/17.
//  Copyright Â© 2017 Mai Anh Vu. All rights reserved.
//

#import "WMIdentifiedFiducial.h"
#import "WMFiducial.h"

#ifdef __cplusplus
#include <iostream>
#endif

@implementation WMIdentifiedFiducial

//-----------------------------------------------------------------------------
#pragma mark - Constants
//-----------------------------------------------------------------------------
static double P_S[96] = {
    -210, -80, 170, 1,    0,   0,   0, 0, -210, -80, 170, 1,
    0,   0,   0, 0, -210, -80, 170, 1, -210, -80, 170, 1,
    -70, -80, 170, 1,    0,   0,   0, 0,  -70, -80, 170, 1,
    0,   0,   0, 0,  -70, -80, 170, 1,  -70, -80, 170, 1,
    -70, -80,  30, 1,    0,   0,   0, 0,  -70, -80,  30, 1,
    0,   0,   0, 0,  -70, -80,  30, 1,  -70, -80,  30, 1,
    -210, -80,  30, 1,    0,   0,   0, 0, -210, -80,  30, 1,
    0,   0,   0, 0, -210, -80,  30, 1, -210, -80,  30, 1,
};

static double P_T[96] = {
    -210,  30, 0, 1,    0,   0, 0, 0, -210,  30, 0, 1,
       0,   0, 0, 0, -210,   0, 0, 1, -210,  30, 0, 1,
     -70,  30, 0, 1,    0,   0, 0, 0,  -70,  30, 0, 1,
       0,   0, 0, 0,  -70,  30, 0, 1,  -70,  30, 0, 1,
     -70, 170, 0, 1,    0,   0, 0, 0,  -70, 170, 0, 1,
       0,   0, 0, 0,  -70, 170, 0, 1,  -70, 170, 0, 1,
    -210, 170, 0, 1,    0,   0, 0, 0, -210, 170, 0, 1,
       0,   0, 0, 0, -210, 170, 0, 1, -210, 170, 0, 1
};

static double P_A[96] = {
    -210, 270, 0, 1,    0,   0, 0, 0, -210, 270, 0, 1,
       0,   0, 0, 0, -210,   0, 0, 1, -210, 270, 0, 1,
     -70, 270, 0, 1,    0,   0, 0, 0,  -70, 270, 0, 1,
       0,   0, 0, 0,  -70, 270, 0, 1,  -70, 270, 0, 1,
     -70, 410, 0, 1,    0,   0, 0, 0,  -70, 410, 0, 1,
       0,   0, 0, 0,  -70, 410, 0, 1,  -70, 410, 0, 1,
    -210, 410, 0, 1,    0,   0, 0, 0, -210, 410, 0, 1,
       0,   0, 0, 0, -210, 410, 0, 1, -210, 410, 0, 1
};

static double P_N[96] = {
    -210, 510, 0, 1,    0,   0, 0, 0, -210, 510, 0, 1,
       0,   0, 0, 0, -210,   0, 0, 1, -210, 510, 0, 1,
     -70, 510, 0, 1,    0,   0, 0, 0,  -70, 510, 0, 1,
       0,   0, 0, 0,  -70, 510, 0, 1,  -70, 510, 0, 1,
     -70, 650, 0, 1,    0,   0, 0, 0,  -70, 650, 0, 1,
       0,   0, 0, 0,  -70, 650, 0, 1,  -70, 650, 0, 1,
    -210, 650, 0, 1,    0,   0, 0, 0, -210, 650, 0, 1,
       0,   0, 0, 0, -210, 650, 0, 1, -210, 650, 0, 1
};

static double P_F[96] = {
    1210, -80, 170, 1,    0,   0,   0, 0, 1210, -80, 170, 1,
       0,   0,   0, 0, 1210, -80, 170, 1, 1210, -80, 170, 1,
    1350, -80, 170, 1,    0,   0,   0, 0, 1350, -80, 170, 1,
       0,   0,   0, 0, 1350, -80, 170, 1, 1350, -80, 170, 1,
    1350, -80,  30, 1,    0,   0,   0, 0, 1350, -80,  30, 1,
       0,   0,   0, 0, 1350, -80,  30, 1, 1350, -80,  30, 1,
    1210, -80,  30, 1,    0,   0,   0, 0, 1210, -80,  30, 1,
       0,   0,   0, 0, 1210, -80,  30, 1, 1210, -80,  30, 1,
};

static double P_O[96] = {
    1210,  30, 0, 1,    0,   0, 0, 0, 1210,  30, 0, 1,
       0,   0, 0, 0, 1210,   0, 0, 1, 1210,  30, 0, 1,
    1350,  30, 0, 1,    0,   0, 0, 0, 1350,  30, 0, 1,
       0,   0, 0, 0, 1350,  30, 0, 1, 1350,  30, 0, 1,
    1350, 170, 0, 1,    0,   0, 0, 0, 1350, 170, 0, 1,
       0,   0, 0, 0, 1350, 170, 0, 1, 1350, 170, 0, 1,
    1210, 170, 0, 1,    0,   0, 0, 0, 1210, 170, 0, 1,
       0,   0, 0, 0, 1210, 170, 0, 1, 1210, 170, 0, 1
};                                    

static double P_R[96] = {
    1210, 270, 0, 1,    0,   0, 0, 0, 1210, 270, 0, 1,
       0,   0, 0, 0, 1210,   0, 0, 1, 1210, 270, 0, 1,
    1350, 270, 0, 1,    0,   0, 0, 0, 1350, 270, 0, 1,
       0,   0, 0, 0, 1350, 270, 0, 1, 1350, 270, 0, 1,
    1350, 410, 0, 1,    0,   0, 0, 0, 1350, 410, 0, 1,
       0,   0, 0, 0, 1350, 410, 0, 1, 1350, 410, 0, 1,
    1210, 410, 0, 1,    0,   0, 0, 0, 1210, 410, 0, 1,
       0,   0, 0, 0, 1210, 410, 0, 1, 1210, 410, 0, 1
};                                    

static double P_D[96] = {
    1210, 510, 0, 1,    0,   0, 0, 0, 1210, 510, 0, 1,
       0,   0, 0, 0, 1210,   0, 0, 1, 1210, 510, 0, 1,
    1350, 510, 0, 1,    0,   0, 0, 0, 1350, 510, 0, 1,
       0,   0, 0, 0, 1350, 510, 0, 1, 1350, 510, 0, 1,
    1350, 650, 0, 1,    0,   0, 0, 0, 1350, 650, 0, 1,
       0,   0, 0, 0, 1350, 650, 0, 1, 1350, 650, 0, 1,
    1210, 650, 0, 1,    0,   0, 0, 0, 1210, 650, 0, 1,
       0,   0, 0, 0, 1210, 650, 0, 1, 1210, 650, 0, 1
};                                    

//-----------------------------------------------------------------------------
#pragma mark - Initialization
//-----------------------------------------------------------------------------
- (instancetype)initWithFiducial:(WMFiducial *)fiducial
                      identifier:(NSUInteger)identifier {

    self = [super init];

    if (self) {
        _fiducial = fiducial;
        _identifier = identifier;
    }

    return self;
}

- (void)generateMatrixP:(OutputArray)outP {
    Mat multipliers = -self.fiducial.uprightVertices.reshape(1, self.fiducial.uprightVertices.rows * 2);
    outP.create(8, 12, CV_64F);
    double *pixelValues;

    switch (self.identifier) {
        case 0: pixelValues = P_S; break;
        case 1: pixelValues = P_T; break;
        case 2: pixelValues = P_A; break;
        case 3: pixelValues = P_N; break;
        case 4: pixelValues = P_F; break;
        case 5: pixelValues = P_O; break;
        case 6: pixelValues = P_R; break;
        case 7: pixelValues = P_D; break;
        default: return;
    }

    Mat(8, 12, CV_64F, pixelValues).copyTo(outP.getMatRef());
    for (int col = 8; col < 12; ++col) {
        multiply(outP.getMatRef().col(col),
                 multipliers,
                 outP.getMatRef().col(col));
    }
}

@end
